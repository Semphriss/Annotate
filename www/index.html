<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, maximum-scale=1.0">
    <title>Annotate</title>
    <style>
      html, body {
        background-color: #333843;
        margin: 0;
        padding: 0;
      }

      canvas {
        display: block;
        box-shadow: 0 4px 10px black;
        margin: 15px;
        width: calc(100% - 30px);
      }

      #loadfile {
        display: block;
        margin: auto;
      }

      #pages {
        margin-bottom: 64px;
      }

      #loading {
        background: #0007;
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        z-index: 999999999;
      }

      .spinner {
        display: block;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        border: 5px solid white;
        border-top: 5px solid #0000;
        width: 50px;
        height: 50px;
        border-radius: 100%;
        animation: spin 1s cubic-bezier(0.68, -0.6, 0.32, 1.6) 0s infinite;
      }

      @keyframes spin {
        0% {
          transform: translate(-50%, -50%) rotate(0deg);
        }
        100% {
          transform: translate(-50%, -50%) rotate(360deg);
        }
      }

      .hide {
        display: none;
      }

      #toolbox {
        display: flex;
        position: fixed;
        height: 298px;
        width: 100%;
        bottom: -258px;
        left: -8px;
        right: -8px;
        background-color: #dde;
        box-shadow: 0 0 5px black;
        flex-direction: column;
        align-items: center;
        justify-content: flex-start;
        padding: 5px;
      }

      #toolbar {
        display: flex;
        flex-direction: row;
        align-items: flex-start;
        justify-content: center;
      }

      #toolbar > * {
        width: 40px;
        height: 40px;
        border-radius: 4px;
        padding: 8px;
        background: none;
        border: none;
        margin: 0 2px;
      }

      #toolbar > .selected {
        background: #7777;
      }

      #toolbar-extended {
        display: block;
        height: 180px;
        width: calc(100% - 20px);
        background-color: #0007;
        margin: 10px;
      }
    </style>
  </head>
  <body>
    <div id="pages"></div>
    <div id="toolbox">
      <div id="toolbar">
        <button id="tool-pencil">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Pro 6.1.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path d="M362.7 19.32C387.7-5.678 428.3-5.678 453.3 19.32L492.7 58.75C517.7 83.74 517.7 124.3 492.7 149.3L444.3 197.7L314.3 67.72L362.7 19.32zM421.7 220.3L188.5 453.4C178.1 463.8 165.2 471.5 151.1 475.6L30.77 511C22.35 513.5 13.24 511.2 7.03 504.1C.8198 498.8-1.502 489.7 .976 481.2L36.37 360.9C40.53 346.8 48.16 333.9 58.57 323.5L291.7 90.34L421.7 220.3z"/></svg>
        </button>
        <button id="tool-highlighter">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Pro 6.1.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path d="M143.1 320V248.3C143.1 233 151.2 218.7 163.5 209.6L436.6 8.398C444 2.943 452.1 0 462.2 0C473.6 0 484.5 4.539 492.6 12.62L547.4 67.38C555.5 75.46 559.1 86.42 559.1 97.84C559.1 107 557.1 115.1 551.6 123.4L350.4 396.5C341.3 408.8 326.1 416 311.7 416H239.1L214.6 441.4C202.1 453.9 181.9 453.9 169.4 441.4L118.6 390.6C106.1 378.1 106.1 357.9 118.6 345.4L143.1 320zM489.4 99.92L460.1 70.59L245 229L330.1 314.1L489.4 99.92zM23.03 466.3L86.06 403.3L156.7 473.9L125.7 504.1C121.2 509.5 115.1 512 108.7 512H40C26.75 512 16 501.3 16 488V483.3C16 476.1 18.53 470.8 23.03 466.3V466.3z"/></svg>
        </button>
        <button id="tool-eraser">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Pro 6.1.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path d="M480 416C497.7 416 512 430.3 512 448C512 465.7 497.7 480 480 480H150.6C133.7 480 117.4 473.3 105.4 461.3L25.37 381.3C.3786 356.3 .3786 315.7 25.37 290.7L258.7 57.37C283.7 32.38 324.3 32.38 349.3 57.37L486.6 194.7C511.6 219.7 511.6 260.3 486.6 285.3L355.9 416H480zM265.4 416L332.7 348.7L195.3 211.3L70.63 336L150.6 416L265.4 416z"/></svg>
        </button>
        <button id="tool-hand" class="selected">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Pro 6.1.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path d="M480 128v208c0 97.05-78.95 176-176 176h-37.72c-53.42 0-103.7-20.8-141.4-58.58l-113.1-113.1C3.906 332.5 0 322.2 0 312C0 290.7 17.15 272 40 272c10.23 0 20.47 3.906 28.28 11.72L128 343.4V64c0-17.67 14.33-32 32-32s32 14.33 32 32l.0729 176C192.1 248.8 199.2 256 208 256s16.07-7.164 16.07-16L224 32c0-17.67 14.33-32 32-32s32 14.33 32 32l.0484 208c0 8.836 7.111 16 15.95 16S320 248.8 320 240L320 64c0-17.67 14.33-32 32-32s32 14.33 32 32l.0729 176c0 8.836 7.091 16 15.93 16S416 248.8 416 240V128c0-17.67 14.33-32 32-32S480 110.3 480 128z"/></svg>
        </button>
      </div>
      <div id="toolbar-extended">
        <input id="loadfile" type="file" accept="application/pdf" />
      </div>
    </div>
    <div id="loading" class="hide"><div class="spinner"></div></div>
    <script src="pdf.js"></script>
    <script>
      /**
       * @licstart The following is the entire license notice for the
       * JavaScript code in this page
       *
       * Copyright 2022 Semphris <semphris@semphris.com>
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *     http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       *
       * @licend The above is the entire license notice for the
       * JavaScript code in this page
       */

      var pdfjsLib = window['pdfjs-dist/build/pdf'];
      pdfjsLib.GlobalWorkerOptions.workerSrc = 'pdf.worker.js';

      const pagesContainer = document.getElementById('pages');
      const loadfile = document.getElementById('loadfile');
      const loader = document.getElementById('loading');
      const toolbox = document.getElementById('toolbox');

      // Toolbox height (distance for the expansion)
      const tbH = 200;

      var currentPdf = null;
      var pdfCanvases = [];
      var docPages = [];
      var currentTool = null;
      var zoom = 1.0;

      function StrokeElement(startX, startY, color, lineWidth, relative) {
        this.color = color;
        this.lineWidth = lineWidth;
        this.relative = relative;
        this.points = [{
          x: startX,
          y: startY
        }];
        this.erased = false;
        this.draw = (page) => {
          page.ctx.save()

          if (this.erased) {
            page.ctx.globalAlpha = 0.5;
          }

          page.ctx.strokeStyle = this.color;
          page.ctx.lineWidth = this.lineWidth *
                               (this.relative ? page.canvas.width : 1);
          page.ctx.lineCap = "round";
          page.ctx.lineJoin = "round";
          page.ctx.beginPath();
          page.ctx.moveTo(this.points[0].x * page.canvas.width,
                          this.points[0].y * page.canvas.height);

          for (const point of this.points) {
            page.ctx.lineTo(point.x * page.canvas.width,
                            point.y * page.canvas.height);
          }

          page.ctx.stroke();
          page.ctx.restore();
        };
        this.touches = (page, point, lastPoint, range) => {
          for (var i = 0; i < this.points.length; i++) {
            const myPoint = this.points[i];
            const lineWidth = this.lineWidth
                                * (this.relative ? page.canvas.width : 1);
            const dist = Math.sqrt(Math.pow((myPoint.x - point.x)
                                    * page.canvas.width, 2)
                        + Math.pow((myPoint.y - point.y)
                                    * page.canvas.height, 2));

            if (dist < (lineWidth + range) / 2)
              return true;

            // Taken from https://stackoverflow.com/questions/9043805/test-if-two-lines-intersect-javascript-function
            function intersects(a,b,c,d,p,q,r,s){
              var γ,λ,𝐴=(c-a)*(s-q)-(r-p)*(d-b);
              return 0!==𝐴&&(γ=((b-d)*(r-a)+(c-a)*(s-b))/𝐴,
                      0<(λ=((s-q)*(r-a)+(p-r)*(s-b))/𝐴)&&λ<1&&0<γ&&γ<1)
            }

            if (lastPoint && i > 0 && intersects(myPoint.x, myPoint.y,
                  this.points[i - 1].x, this.points[i - 1].y, point.x, point.y,
                  lastPoint.x, lastPoint.y))
              return true;
          }
          return false;
        };
      }

      function PenTool(color, size, relativeToScreen) {
        this.currentStroke = null;
        this.oldX = 0;
        this.oldY = 0;
        this.color = color || 'black';
        this.size = size || 1;
        this.sizeRelativeToScreen = relativeToScreen;
        this.ondown = (e, page) => {
          if (this.currentStroke)
            return;

          var x = e.layerX, y = e.layerY;
          if (e.touches) {
            if (e.touches.length != 1)
              return;

            x = e.touches[0].pageX;
            y = e.touches[0].pageY;
          }

          e.preventDefault();

          this.oldX = x - page.canvas.offsetLeft;
          this.oldY = y - page.canvas.offsetTop;

          const point = {
            x: this.oldX / page.canvas.width * window.devicePixelRatio / zoom,
            y: this.oldY / page.canvas.height * window.devicePixelRatio / zoom
          };

          var size = this.size;
          if (this.sizeRelativeToScreen) {
            size /= page.canvas.width;
          } else {
            size /= 1920;
          }

          this.currentStroke = new StrokeElement(point.x, point.y, this.color,
                                                 size, true);
          this.currentStroke.page = page;
          page.elements.push(this.currentStroke);
          page.redraw();
        };
        this.onmove = (e, page) => {
          if (!this.currentStroke)
            return;

          var x = e.layerX, y = e.layerY;
          if (e.touches) {
            if (e.touches.length != 1)
              return;

            x = e.touches[0].pageX;
            y = e.touches[0].pageY;
          }

          e.preventDefault();

          this.oldX = x - page.canvas.offsetLeft;
          this.oldY = y - page.canvas.offsetTop;

          page.elements[page.elements.length - 1].points.push({
            x: this.oldX / page.canvas.width * window.devicePixelRatio / zoom,
            y: this.oldY / page.canvas.height * window.devicePixelRatio / zoom
          });

          page.redraw();
        };
        this.onup = (e, page) => {
          e.preventDefault();
          this.currentStroke = null;
        };
        this.cancel = () => {
          if (this.currentStroke) {
            for (var i = 0; i < this.currentStroke.page.elements.length; i++) {
              if (this.currentStroke.page.elements[i] == this.currentStroke) {
                this.currentStroke.page.elements.splice(i);
                this.currentStroke.page.redraw();
                this.currentStroke = null;
                return;
              }
            }
          }
        }
      }

      function EraserTool(size, relativeToScreen) {
        this.currentStroke = null;
        this.touchedElements = [];
        this.oldX = 0;
        this.oldY = 0;
        this.size = size || 1;
        this.sizeRelativeToScreen = relativeToScreen;
        this.ondown = (e, page) => {
          if (this.currentStroke)
            return;

          var x = e.layerX, y = e.layerY;
          if (e.touches) {
            if (e.touches.length != 1)
              return;

            x = e.touches[0].pageX;
            y = e.touches[0].pageY;
          }

          e.preventDefault();

          this.oldX = x - page.canvas.offsetLeft;
          this.oldY = y - page.canvas.offsetTop;

          const point = {
            x: this.oldX / page.canvas.width * window.devicePixelRatio / zoom,
            y: this.oldY / page.canvas.height * window.devicePixelRatio / zoom
          };

          var size = this.size;
          if (this.sizeRelativeToScreen) {
            size /= page.canvas.width;
          } else {
            size /= 1920;
          }

          this.currentStroke = new StrokeElement(point.x, point.y, '#fff', size,
                                                 true);
          this.currentStroke.page = page;
          page.elements.push(this.currentStroke);

          for (var element of page.elements) {
            // FIXME: Doesn't consider this.currentStroke.relative
            const size = this.size * page.canvas.width / 1920;
            if (element != this.currentStroke
                  && !this.touchedElements.includes(element)
                  && element.touches(page, point, null, size)) {
              element.erased = true;
              this.touchedElements.push(element);
            }
          }

          page.redraw();
        };
        this.onmove = (e, page) => {
          if (!this.currentStroke)
            return;

          var x = e.layerX, y = e.layerY;
          if (e.touches) {
            if (e.touches.length != 1)
              return;

            x = e.touches[0].pageX;
            y = e.touches[0].pageY;
          }

          e.preventDefault();

          const oldPoint = {
            x: this.oldX / page.canvas.width * window.devicePixelRatio / zoom,
            y: this.oldY / page.canvas.height * window.devicePixelRatio / zoom
          };

          this.oldX = x - page.canvas.offsetLeft;
          this.oldY = y - page.canvas.offsetTop;

          const point = {
            x: this.oldX / page.canvas.width * window.devicePixelRatio / zoom,
            y: this.oldY / page.canvas.height * window.devicePixelRatio / zoom
          };

          page.elements[page.elements.length - 1].points.push(point);

          for (var element of page.elements) {
            // FIXME: Doesn't consider this.currentStroke.relative
            const size = this.size * page.canvas.width / 1920;
            if (element != this.currentStroke
                  && !this.touchedElements.includes(element)
                  && element.touches(page, point, oldPoint, size)) {
              element.erased = true;
              this.touchedElements.push(element);
            }
          }

          page.redraw();
        };
        this.onup = (e, page) => {
          if (this.currentStroke) {
            e.preventDefault();
            for (var i = 0; i < this.currentStroke.page.elements.length; i++) {
              const element = this.currentStroke.page.elements[i];
              if (element == this.currentStroke) {
                this.currentStroke.page.elements.splice(i, 1);
                i--;
              } else if (this.touchedElements.includes(element)) {
                this.currentStroke.page.elements.splice(i, 1);
                i--;
              }
            }

            this.currentStroke.page.redraw();
            this.currentStroke = null;
          }
        };
        this.cancel = () => {
          if (this.currentStroke) {
            for (var i = 0; i < this.currentStroke.page.elements.length; i++) {
              if (this.currentStroke.page.elements[i] == this.currentStroke) {
                this.currentStroke.page.elements.splice(i);
                break;
              }
            }
          }

          for (var element of this.touchedElements) {
            element.erased = false;
          }
          this.touchedElements = []

          if (this.currentStroke) {
            this.currentStroke.page.redraw();
            this.currentStroke = null;
          }
        }
      }

      function addPage(pos, pdfPage, size) {
        if (pos == null || pos == undefined) pos = docPages.length;
        if (pos > docPages.length) pos = docPages.length;
        if (pos < 0) pos = 0;

        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        const newDocPage = {
          canvas: canvas,
          ctx: ctx,
          pdfPage: pdfPage || 0,
          elements: [],
          size: {
            w: size && size.w ||
                (pdfPage ? pdfCanvases[pdfPage - 1].width : 1920),
            h: size && size.h ||
                (pdfPage ? pdfCanvases[pdfPage - 1].height : 1080)
          },
          resize() {
            const targetWidth = window.innerWidth - 30;
            const factor = targetWidth / this.size.w;
            this.canvas.width = this.size.w * factor * window.devicePixelRatio;
            this.canvas.height = this.size.h * factor * window.devicePixelRatio;
          },
          redraw() {
            if (this.pdfPage > 0) {
              this.ctx.drawImage(pdfCanvases[pdfPage - 1], 0, 0,
                                 this.canvas.width, this.canvas.height);
            } else {
              this.ctx.fillStyle = 'white';
              this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            }

            for (const element of this.elements) {
              element.draw(this);
            }
          }
        }

        canvas.addEventListener('mousedown', (e) => {
          if (currentTool)
            currentTool.ondown(e, newDocPage);
        });

        canvas.addEventListener('mousemove', (e) => {
          if (currentTool)
            currentTool.onmove(e, newDocPage);
        });

        canvas.addEventListener('mouseup', (e) => {
          if (currentTool)
            currentTool.onup(e, newDocPage);
        });

        var lastAveragePt = null;
        var lastMaxDist = null;
        canvas.addEventListener('touchstart', (e) => {
          // TODO: Calculate average touch point and set it

          if (currentTool)
            currentTool.ondown(e, newDocPage);
        });

        canvas.addEventListener('touchmove', (e) => {
          if (e.touches.length >= 2 || !currentTool) {
            e.preventDefault();

            if (currentTool && typeof currentTool.cancel === 'function')
              currentTool.cancel();

            const averagePt = { x: 0, y: 0 };
            for (const touch of e.touches) {
              averagePt.x += touch.clientX;
              averagePt.y += touch.clientY;
            }
            averagePt.x /= e.touches.length;
            averagePt.y /= e.touches.length;

            var maxDist = 0;
            for (const touch of e.touches) {
              for (const touch2 of e.touches) {
                const dist = Math.sqrt(Math.pow(touch.clientX - touch2.clientX,
                              2) + Math.pow(touch.clientY - touch2.clientY, 2));
                if (maxDist < dist)
                  maxDist = dist;
              }
            }

            if (lastAveragePt) {
              window.scrollBy(lastAveragePt.x - averagePt.x,
                              lastAveragePt.y - averagePt.y);
            }

            if (lastMaxDist) {
              zoom *= maxDist / lastMaxDist;
              zoom = Math.max(1, Math.min(10, zoom));
              const pages = document.getElementById("pages");
              pages.style.width = (zoom * 100) + "%";
            }

            lastAveragePt = averagePt;
            lastMaxDist = maxDist;
            return;
          }

          lastAveragePt = null;
          lastMaxDist = null;

          if (currentTool)
            currentTool.onmove(e, newDocPage);
        });

        canvas.addEventListener('touchend', (e) => {
          lastAveragePt = null;
          lastMaxDist = null;

          if (currentTool)
            currentTool.onup(e, newDocPage);
        });

        newDocPage.resize();
        newDocPage.redraw();

        docPages.splice(pos, 0, newDocPage);

        if (pos >= docPages.length - 1)
          pagesContainer.append(canvas);
        else
          pagesContainer.insertBefore(canvas, docPages[pos].canvas);
      }

      async function loadPdf(isReload) {
        pdfCanvases = [];
        if (!isReload) {
          docPages = [];
          pagesContainer.innerHTML = '';
        }

        for (var num = 1; num <= currentPdf.numPages; num++) {
          const page = await currentPdf.getPage(num);

          const canvas = document.createElement('canvas');
          const scale = (window.innerWidth - 30) * window.devicePixelRatio
                          / page.getViewport({ scale: 1 }).width;

          const viewport = page.getViewport({ scale: scale });
          canvas.height = viewport.height;
          canvas.width = viewport.width;

          await page.render({
            canvasContext: canvas.getContext('2d'),
            viewport: viewport
          }).promise;

          pdfCanvases.push(canvas);

          if (!isReload) {
            addPage(num - 1, num);
          }
        }

        if (isReload) {
          for (const page of docPages) {
            page.resize();
            page.redraw();
          }
        }
      }

      loadfile.addEventListener('change', () => {
        if (loadfile.files.length === 0)
          return;

        loader.classList.remove('hide');

        var reader = new FileReader();
        reader.onload = async function(event) {
          const data = event.target.result;
          currentPdf = await pdfjsLib.getDocument({ data: data }).promise;
          await loadPdf(false);
          loader.classList.add('hide');
        };

        reader.readAsBinaryString(loadfile.files[0]);
      });

      var currentWidth = 0;
      window.addEventListener('resize', function(event) {
        if (!currentPdf)
          return;

        for (const page of docPages) {
          page.resize();
          page.redraw();
        }

        if (currentWidth == window.innerWidth)
          return;

        const startWidth = window.innerWidth;
        setTimeout(() => {
          // If we're back where we started, or if the window is still changing
          // size (the user is still resizing the window), don't redraw
          if (currentWidth == window.innerWidth
              || window.innerWidth != startWidth)
            return;

          currentWidth = window.innerWidth;

          loadPdf(true);
        }, 250)
      }, true);

      function switchSelectedTool(tool) {
        const selecteds = document.getElementsByClassName("selected");
        while (selecteds.length) {
          selecteds[0].classList.remove("selected");
        }
        document.getElementById(tool).classList.add("selected");
      }

      document.getElementById("tool-pencil").addEventListener('click', (e) => {
        switchSelectedTool("tool-pencil");
        currentTool = new PenTool('#000', 3, false);
      });

      document.getElementById("tool-highlighter").addEventListener('click',
                                                                   (e) => {
        switchSelectedTool("tool-highlighter");
        currentTool = new PenTool('#ff07', 30, false);
      });

      document.getElementById("tool-eraser").addEventListener('click', (e) => {
        switchSelectedTool("tool-eraser");
        currentTool = new EraserTool(20, false);
      });

      document.getElementById("tool-hand").addEventListener('click', (e) => {
        switchSelectedTool("tool-hand");
        currentTool = null;
      });

      var toolboxExpanded = false;
      var toolboxMoving = false;
      var toolboxOrigin = NaN;
      var toolboxLastY = NaN;
      var toolboxLastMovement = NaN;
      toolbox.addEventListener('touchstart', (e) => {
        if (e.touches.length !== 1)
          return;

        // No e.preventDefault(), to allow tapping on tools

        toolboxOrigin = e.touches[0].pageY;
        toolboxLastY = toolboxExpanded ? -tbH : 0;
      });

      toolbox.addEventListener('touchmove', (e) => {
        if (e.touches.length !== 1 || isNaN(toolboxOrigin))
          return;

        e.preventDefault();

        const start = toolboxExpanded ? -tbH : 0;
        var offset = e.touches[0].pageY - toolboxOrigin;
        if (Math.abs(offset) > 10 || toolboxMoving) {
          toolboxMoving = true;
          if (offset + start < -tbH) {
            offset = -Math.sqrt(-offset - tbH - start) - tbH - start;
          } else if (offset + start > 0) {
            offset = -start;
          }
          toolbox.style.transform = 'translateY(' + (offset + start) + 'px)';
        } else {
          toolbox.style.transform = 'translateY(' + start + 'px)';
        }

        var newY = offset + start;
        var newMov = newY - toolboxLastY;
        toolboxLastY = newY;
        toolboxLastMovement = newMov;
      });

      toolbox.addEventListener('touchend', (e) => {
        if (isNaN(toolboxOrigin))
          return;

        // Don't prevent tapping on tools
        if (toolboxMoving)
          e.preventDefault();

        if (Math.abs(toolboxLastMovement) > 10) {
          toolboxExpanded = toolboxLastMovement < 0;
        } else {
          toolboxExpanded = toolboxLastY < -tbH / 2;
        }
        toolboxOrigin = NaN;
        toolboxLastY = NaN;
        toolboxLastMovement = NaN;
        toolboxMoving = false;

        toolbox.style.transform = toolboxExpanded ? 'translateY(-' + tbH + 'px)'
                                                  : '';
      });
    </script>
  </body>
</html>
